//
//  FirestoreApi.swift
//  YumFun
//
//  Created by Yibo Yan on 2021/2/20.
//

import Foundation
import Firebase

class FirestoreApi {
    // - MARK: Handler Type
    typealias postDataCompletionHandler = (Error?, DocumentReference?) -> Void
    typealias fetchAllDataCompletionHandler<T: Decodable> = (Error?, [T]?, QuerySnapshot?) -> Void
    typealias updateDataCompletionHandler = (Error?) -> Void
    
    private static let db = Firestore.firestore()
    
    /**
     Post data in the specified collection to the cloud.
     
     - Parameter collectionPath: which collection you want to post data in
     - Parameter data: Encodable data you want to post to the cloud
     - Parameter completion: completion handler takes two arguments, error and document reference.
     
     ## Note
     The document id will be automatically generated by Firestore.
     
     You can access the automatically created id in the completion handler like:
     ```
     postData(in: "NewCollection", with: data) { (err, ref) in
        let id = ref?.documentID
     }
     ```
     */
    static func postData<T: Encodable>(in collectionPath: String,
                                       with data: T,
                                       _ completion: @escaping postDataCompletionHandler) {
        var ref: DocumentReference? = nil
        ref = try? db.collection(collectionPath).addDocument(from: data) { err in
            completion(err, ref)
        }
    }
    
    /**
     Post data in the specified collection with specific name to the cloud.
     
     - Parameter collection: which collection you want to post data in
     - Parameter data: encodable data you want to post to the cloud
     - Parameter docName: name or doc id you want to set
     - Parameter merge: define whether merge behavior is used. Override behavior by default.
     - Parameter completion: completion handler takes two arguments, error and document reference.
     
     ## Be Caution!
     By default, new data will automatically override the old data in the specified document. You can set `merge` argument to `true` to perform merge action, instead of override. If you are using `merge` option, maybe you want to use `updateData` instead.
     
     __!!! Last updated date will not be updated by calling post functions, considering using update functions__
     
     ## Note
     Document reference passed into the completion handler will always be `nil`. The document id is identical to what you named it.
     */
    static func postData<T: Encodable>(in collectionPath: String,
                                       with data: T,
                                       named docName: String,
                                       merge: Bool = false,
                                       _ completion: @escaping postDataCompletionHandler) {
        do {
            try db.collection(collectionPath).document(docName).setData(from: data,
                                                                        merge: merge) { (err) in
                completion(err, nil)
            }
        } catch {
            completion(error, nil)
        }
    }
    
    /**
     Update partial data with specified collection path and document name/id, by passing a dictionary-like data.
     
     - Parameter collectionPath: which collection you want to update data in
     - Parameter docName: which document you want to update data in
     - Parameter data: partial data you want to update
     - Parameter trackUpdate: whether you want to update the `lastUpdated` field
     - Parameter completion: completion handler for data update action
     */
    static func updateData(in collectionPath: String,
                           named docName: String,
                           with data: [AnyHashable : Any],
                           trackUpdate: Bool = true,
                           _ completion: @escaping updateDataCompletionHandler) {
        var data = data
        if trackUpdate {
            data["lastUpdated"] = FieldValue.serverTimestamp()
        }
        
        db.collection(collectionPath).document(docName).updateData(data) { (err) in
            completion(err)
        }
    }
    
    /**
     Update data with specified collection path and document name/id, by passing a `Encodable` object.
     
     - Parameter collectionPath: which collection you want to update data in
     - Parameter docName: which document you want to update data in
     - Parameter data: `Encodable` data object you want to update
     - Parameter trackUpdate: whether you want to update the `lastUpdated` field
     - Parameter completion: completion handler for data update action
     */
    static func updateData(in collectionPath: String,
                           named docName: String,
                           with data: Encodable,
                           trackUpdate: Bool = true,
                           _ completion: @escaping updateDataCompletionHandler) {
        do {
            let data = try data.toFirebaseDict()
            self.updateData(in: collectionPath, named: docName, with: data, completion)
        } catch {
            completion(error)
        }
    }
    
    static func fetchAllData<T: Decodable>(in collection: String,
                                           _ completion: @escaping fetchAllDataCompletionHandler<T>) {
        db.collection(collection).getDocuments() { (querySnapshot, err) in
            let docs = querySnapshot?.documents.compactMap { document -> T? in
                let result = Result {
                    try document.data(as: T.self)
                }
                
                switch result {
                case .success(let data):
                    return data
                case .failure(let error):
                    print("Error decoding data: \(error)")
                    return nil
                }
//                return try? document.data(as: T.self)
            }
            completion(err, docs, querySnapshot)
        }
    }
}

// - MARK: Convinent Functions for Recipe operations
extension FirestoreApi {
    /**
     Post a recipe to the cloud. All recipe will be saved to the top-level collection named `recipe`. The document name/id will be randomly generated.
     */
    static func postRecipe(with recipe: Recipe,
                           _ completion: @escaping postDataCompletionHandler) {
        self.postData(in: "recipe", with: recipe, completion)
    }
    
    /**
     Update a recipe to the cloud. You can update partial data by passing in a dictionary-like object.
     */
    static func updateRecipe(named name: String,
                             with data: [AnyHashable : Any],
                             trackUpdate: Bool = true,
                             _ completion: @escaping updateDataCompletionHandler) {
        self.updateData(in: "recipe", named: name, with: data, trackUpdate: trackUpdate, completion)
    }
    
    /**
     Update a recipe to the cloud. You can update an entire recipe by passing in a `Recipe` object.
     
     ## Note
     If you want to create a entire new recipe, considering using `postRecipe()` function.
     */
    static func updateRecipe(named name: String,
                             with data: Recipe,
                             trackUpdate: Bool = true,
                             _ completion: @escaping updateDataCompletionHandler) {
        self.updateData(in: "recipe", named: name, with: data, trackUpdate: trackUpdate, completion)
    }
}

// - MARK: Test Functions
extension FirestoreApi {
    /**
     This test fuction will create a demo document in the collection `tests`.
     */
    static func testPostData() {
        var ref: DocumentReference? = nil
        ref = db.collection("tests").addDocument(data: [
            "first": "Ada",
            "last": "Lovelace",
            "born": 1815
        ]) { err in
            if let err = err {
                print("Error adding document: \(err)")
            } else {
                print("Document added with ID: \(ref!.documentID)")
            }
        }
    }
}
